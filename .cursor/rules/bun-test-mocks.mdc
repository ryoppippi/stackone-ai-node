---
description: bun testing mocks
globs: *.spec.ts
alwaysApply: false
---
# Bun Mocks

This document outlines the standards for writing tests using Bun's testing framework in this repository.

## HTTP Request Mocking with MSW

### Prefer MSW Over fetch Mocking

**Always use MSW (Mock Service Worker) for mocking HTTP requests** instead of `spyOn(globalThis, 'fetch')`.

MSW is already configured globally in `bun.test.setup.ts`, so you don't need to set up the server in individual test files.

#### Adding Mock Handlers

Add your mock endpoints to `mocks/handlers.ts`:

```typescript
import { http, HttpResponse } from 'msw';

export const handlers = [
  http.get('https://api.example.com/endpoint', () => {
    return HttpResponse.json({ data: 'mock response' });
  }),
  // ... other handlers
];
```

#### Overriding Handlers in Tests

Use `server.use()` to override handlers for specific test cases:

```typescript
import { http, HttpResponse } from 'msw';
import { server } from '../../../mocks/node';

it('handles error responses', async () => {
  server.use(
    http.get('https://api.example.com/endpoint', () => {
      return HttpResponse.json({ error: 'Not found' }, { status: 404 });
    })
  );

  // Your test code here
});
```

The global `afterEach` hook in `bun.test.setup.ts` automatically calls `server.resetHandlers()` to reset overrides.

#### Verifying Requests

Use MSW's event listeners to verify that requests were made:

```typescript
it('makes the expected request', async () => {
  const recordedRequests: Request[] = [];
  const listener = ({ request }: { request: Request }) => {
    recordedRequests.push(request);
  };
  server.events.on('request:start', listener);

  // Make your request
  await someFunction();

  expect(recordedRequests).toHaveLength(1);
  expect(recordedRequests[0]?.url).toBe('https://api.example.com/endpoint');

  server.events.removeListener('request:start', listener);
});
```

**Important:**
- Do NOT use `spyOn(globalThis, 'fetch')` for HTTP mocking - use MSW instead
- Do NOT add `beforeAll`/`afterAll`/`afterEach` for MSW setup in test files - it's already configured globally
- MSW handlers are reset after each test automatically
- For tests that need to run their own servers (e.g., MCP servers), you may need to temporarily close and restart MSW

## File System Testing

### Use fs-fixture for File System Operations

For tests that need to work with the file system, use [fs-fixture](https://github.com/privatenumber/fs-fixture) to create temporary test directories with automatic cleanup.

**IMPORTANT: Always use `await using` syntax - do NOT manually manage fixture lifecycle.**

**Basic Usage:**

```typescript
import { createFixture } from 'fs-fixture';

it('should save file to disk', async () => {
  // Using 'await using' ensures automatic cleanup
  await using fixture = await createFixture();

  // Write files using fixture methods
  await fixture.writeFile('data.json', JSON.stringify({ test: 'data' }));

  // Verify and read
  expect(await fixture.exists('data.json')).toBe(true);
  const content = await fixture.readFile('data.json', 'utf8');
  expect(JSON.parse(content)).toEqual({ test: 'data' });
});
```

**Pre-populated Fixtures:**

```typescript
it('should read existing files', async () => {
  await using fixture = await createFixture({
    'config.json': JSON.stringify({ setting: 'value' }),
    'data/file.txt': 'content',
  });

  // Files are already created at fixture.path
  const result = await processConfig(fixture.path);
  expect(result).toBeDefined();
});
```

**Type-Safe JSON:**

```typescript
interface Config { name: string; version: string; }

await using fixture = await createFixture();
await fixture.writeJson('config.json', { name: 'test', version: '1.0.0' }, 2);
const config = await fixture.readJson<Config>('config.json');
```

**Key Methods:**
- `fixture.path` - Absolute path to fixture directory
- `fixture.exists(path)` - Check if file/directory exists
- `fixture.readFile(path, encoding?)` - Read file
- `fixture.writeFile(path, content)` - Write file
- `fixture.readJson<T>(path)` - Parse JSON with types
- `fixture.writeJson(path, data, space?)` - Write formatted JSON
- `fixture.mkdir(path)` - Create directories

**Benefits:**
- Automatic cleanup with `await using` - no manual cleanup needed
- Zero dependencies, lightweight (1.1 kB)
- Type-safe JSON operations
- Isolated test environments

**Reference:** See [fs-fixture documentation](https://github.com/privatenumber/fs-fixture) for advanced usage and API details

## Mocking Best Practices

### Use Proper Mocking Functions

For non-HTTP mocking, use the appropriate mocking functions from Bun's testing framework:

- Use `spyOn()` to track calls to existing functions without replacing their implementation
- Use `mock()` to create standalone mock functions
- Use `mock.module()` for module-level mocking

```typescript
// Good: Using spyOn for existing methods
const spy = spyOn(fs, "readFileSync");

// Good: Creating a standalone mock function
const mockFn = mock(() => "mocked result");
```

### Restore Mocks After Tests

Always restore mocks after tests to prevent test pollution:

- Use `mock.restore()` in `afterEach` or `afterAll` hooks
- Alternatively, use `mockFn.mockRestore()` for individual mocks

```typescript
// Good: Restoring all mocks after each test
afterEach(() => {
  mock.restore();
});
```

### Use Test Lifecycle Hooks

Organize test setup and teardown using lifecycle hooks:

- Use `beforeEach` for setting up mocks and test data
- Use `afterEach` for cleaning up mocks and test data
- Use `afterAll` for final cleanup

```typescript
describe("My Test Suite", () => {
  let mySpy;

  beforeEach(() => {
    // Setup mocks
    mySpy = spyOn(myObject, "myMethod");
  });

  afterEach(() => {
    // Clean up
    mock.restore();
  });

  // Tests go here
});
```

### Avoid Global Mocks

Avoid modifying global objects or prototypes directly. Instead:

- Use `spyOn` to mock methods on objects
- Use `mock.module()` to mock entire modules
- Keep mocks scoped to the tests that need them

```typescript
// Bad: Directly modifying a global object
fs.readFileSync = jest.fn();

// Good: Using spyOn
const readFileSpy = spyOn(fs, "readFileSync");
```

### Use Module Mocking Appropriately

When mocking modules:

- Use `mock.module()` before the module is imported when possible
- For modules already imported, be aware that side effects have already occurred
- Consider using `--preload` for mocks that need to be in place before any imports

```typescript
// Good: Module mocking
mock.module("./myModule", () => {
  return {
    myFunction: () => "mocked result",
  };
});
```

### Verify Mock Interactions

Always verify that mocks were called as expected:

- Use `.toHaveBeenCalled()` to verify a function was called
- Use `.toHaveBeenCalledWith()` to verify arguments
- Use `.toHaveBeenCalledTimes()` to verify call count

```typescript
test("my function calls the dependency", () => {
  const spy = spyOn(dependency, "method");
  myFunction();
  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith("expected arg");
  expect(spy).toHaveBeenCalledTimes(1);
});
```

## Test Organization

### Group Related Tests

Use `describe` blocks to group related tests:

```typescript
describe("MyClass", () => {
  describe("myMethod", () => {
    it("should handle valid input", () => {
      // Test with valid input
    });

    it("should handle invalid input", () => {
      // Test with invalid input
    });
  });
});
```

### Write Clear Test Descriptions

Test descriptions should clearly state what is being tested and the expected outcome:

```typescript
// Good: Clear test description
it("should return user data when given a valid user ID", () => {
  // Test implementation
});

// Bad: Vague test description
it("works correctly", () => {
  // Test implementation
});
```

## Additional Resources

- [Bun Testing Documentation](mdc:https:/bun.sh/docs/cli/test)
- [Jest API Reference](mdc:https:/jestjs.io/docs/api) (for compatible APIs)
